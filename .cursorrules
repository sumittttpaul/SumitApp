# Cursor Rules for SumitApp

## Project Context
SumitApp is a CLI tool and template system for scaffolding modern full-stack applications. The repository contains:
- `create-sumit-app/` - CLI tool source code (TypeScript)
- `official-site/` - Next.js documentation website
- `templates/` - Project templates for generated apps
- Generated projects use Turborepo monorepos with Next.js, Expo, and Node.js

## Code Style & Standards

### TypeScript
- Use strict TypeScript configuration
- Prefer explicit return types for functions
- Use `interface` for object shapes, `type` for unions/intersections
- Import types with `import type` when possible
- Use proper error handling with typed error objects

### Package Manager
- Primary package manager is **Bun** - use `bun` commands in scripts and documentation
- Support other package managers but optimize for Bun
- Use `workspace:^` protocol for workspace dependencies
- Include `"packageManager": "bun@1.2.22"` in all package.json files

### File Structure
- Follow established directory conventions:
  - CLI source: `create-sumit-app/src/`
  - Templates: `templates/default/`
  - Shared packages: `packages/`
  - Applications: `projects/`
- Use kebab-case for directory names
- Use PascalCase for React components
- Use camelCase for TypeScript files

### CLI Development
- Use `commander` for CLI argument parsing
- Use `prompts` for interactive input
- Use `ora` for loading indicators
- Use `chalk` for colored output
- Implement proper error handling and user-friendly messages
- Use `degit` for template cloning without Git history
- Support both interactive and non-interactive modes

### Template Development
- Maintain Turborepo workspace structure
- Use `@packages/` namespace for shared packages
- Ensure all workspace dependencies use proper protocols
- Test template generation before committing changes
- Keep turbo.json task dependencies optimized

### React/Next.js (for official-site and templates)
- Use Next.js 15 App Router
- Prefer Server Components when possible
- Use proper TypeScript with React 19 types
- Follow Tailwind CSS 4 conventions
- Use Radix UI for accessible components
- Implement proper error boundaries

### Testing
- Use Vitest for CLI tool testing
- Write unit tests for utility functions
- Include integration tests for template generation
- Maintain test coverage above 80%
- Use descriptive test names and organize in describe blocks

## Architecture Guidelines

### CLI Tool Architecture
- Keep modular structure in `src/lib/`
- Separate concerns: templates, config, utils, logger
- Use dependency injection where appropriate
- Handle cross-platform compatibility (Windows/macOS/Linux)
- Implement proper logging levels (verbose, info, warn, error)

### Template Architecture
- Maintain separation between shared packages and applications
- Use proper workspace dependency management
- Keep build configurations optimized for production
- Implement proper environment variable handling
- Support multiple deployment targets (Vercel, etc.)

### Error Handling
- Provide clear, actionable error messages
- Handle edge cases gracefully (network issues, permissions, etc.)
- Use proper exit codes for CLI operations
- Implement retry logic for network operations
- Log errors appropriately for debugging

## Development Workflow

### Before Making Changes
- Understand the impact on generated projects
- Test CLI changes with actual template generation
- Verify Turborepo task dependencies still work
- Check cross-platform compatibility

### Code Reviews
- Ensure new features have appropriate tests
- Verify documentation is updated
- Check that error messages are user-friendly
- Validate package.json changes across workspaces

### Dependencies
- Prefer established, well-maintained packages
- Avoid unnecessary dependencies
- Keep bundle size reasonable for CLI tool
- Use peer dependencies appropriately in shared packages

## Specific Patterns

### CLI Command Structure
```typescript
// Use this pattern for new CLI commands
const program = new Command()
  .name('command-name')
  .description('Clear description')
  .option('-v, --verbose', 'Enable verbose logging')
  .action(async (options) => {
    const logger = new Logger(options.verbose);
    // Implementation
  });
```

### Template File Operations
```typescript
// Use fs-extra for file operations
import fs from 'fs-extra';

// Always check if paths exist
if (await fs.pathExists(filePath)) {
  // Handle file operations
}
```

### Package Manager Detection
```typescript
// Follow existing pattern for package manager detection
const lockFiles = [
  { name: 'bun', file: 'bun.lockb' },
  { name: 'pnpm', file: 'pnpm-lock.yaml' },
  // ...
];
```

## Documentation
- Keep README files updated with new features
- Update WARP.md when architecture changes
- Include code examples in documentation
- Maintain changelog for CLI releases

## Security
- Validate user input in CLI prompts
- Handle file paths securely
- Don't include secrets in templates or code
- Use secure defaults for generated projects

## Performance
- Optimize CLI startup time
- Use efficient file operations
- Implement proper caching strategies
- Keep generated project build times reasonable